<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Classificação de doenças de pele — Captura e Segmentação</title>
  <style>
    :root {
      --bg:#0f172a; --card:#111827; --muted:#94a3b8; --acc:#22c55e; --warn:#f59e0b; --bad:#ef4444; --good:#10b981; --txt:#e5e7eb;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;color:var(--txt);background:linear-gradient(180deg,#0b1023,#0a122e 40%,#06111f)}
    header{padding:16px 20px;text-align:center}
    header h1{margin:6px 0 2px;font-weight:800;letter-spacing:.3px}
    header p{margin:4px 0;color:var(--muted);font-size:14px}
    .container{max-width:1040px;margin:0 auto;padding:16px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:18px}
    .panel{background:rgba(17,24,39,.65);border:1px solid rgba(255,255,255,.06);border-radius:18px;overflow:hidden;backdrop-filter: blur(6px)}
    .panel header{padding:12px 14px;background:rgba(255,255,255,.03);border-bottom:1px solid rgba(255,255,255,.06);text-align:left}
    .panel header h2{margin:0;font-size:16px}
    .panel .content{padding:14px}
    .btn{appearance:none;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:var(--txt);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:600;transition:.2s}
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.08)}
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .btn.primary{border-color:rgba(34,197,94,.35);background:rgba(34,197,94,.12)}
    .btn.big{padding:16px 22px;font-size:18px;border-radius:999px;min-width:180px}
    .btn.cta{background:linear-gradient(90deg, rgba(34,197,94,.18), rgba(34,197,94,.10));border-color:rgba(34,197,94,.55)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .video-wrap{position:relative;aspect-ratio:3/4;background:#000;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,.08)}
    video{width:100%;height:100%;object-fit:cover;display:block;filter:contrast(1.02) saturate(1.02)}
    .overlay{position:absolute;inset:0;pointer-events:none;background: radial-gradient(circle at 50% 50%, transparent 0 38%, rgba(0,0,0,.64) 39% 100%)}
    .status{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:12px;font-size:14px;color:var(--muted)}
    .pill{padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);font-weight:600}
    .pill.good{border-color:rgba(16,185,129,.45);color:#b7f9de;background:rgba(16,185,129,.08)}
    .pill.warn{border-color:rgba(245,158,11,.45);color:#fde68a;background:rgba(245,158,11,.08)}
    .pill.bad{border-color:rgba(239,68,68,.45);color:#fecaca;background:rgba(239,68,68,.08)}
    canvas{max-width:100%;background:#0b1220;border-radius:12px;border:1px solid rgba(255,255,255,.08)}
    .foot{margin-top:10px;color:var(--muted);font-size:12px}
    input[type=file]{display:none}
    .slider-wrap{margin-top:10px}
    .slider-wrap label{font-size:12px;color:var(--muted)}
    .slider-wrap input{width:100%}

    /* Abas para mobile */
    .tabs{display:none;gap:8px;margin:0 0 12px 0}
    .tab-btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:var(--txt);padding:8px 12px;border-radius:999px;font-weight:700;cursor:pointer}
    .tab-btn.active{background:rgba(34,197,94,.18);border-color:rgba(34,197,94,.55)}
    .tab-panel{display:block}
    .hidden{display:none !important}

    /* Mobile-first */
    @media (max-width: 920px){
      .grid{display:block}
      .panel{margin-bottom:14px}
      .tabs{display:flex}
      .actions{display:flex;flex-direction:column;gap:10px;margin-top:12px}
      .actions .btn{width:100%}
      #capture{order:-1}
    }
  </style>
</head>
<body>
  <header>
    <h1>Classificação de doenças de pele</h1>
    <p>Captura padronizada com máscara circular, estabilidade e crop automático para ROI.</p>
  </header>

  <div class="container">
    <nav class="tabs" aria-label="Navegação por abas">
      <button class="tab-btn active" id="tabCapBtn" aria-controls="panelCapture">Captura</button>
      <button class="tab-btn" id="tabResBtn" aria-controls="panelResult">Resultado</button>
    </nav>

    <div class="grid">
      <!-- Captura -->
      <section class="panel tab-panel" id="panelCapture">
        <header><h2>Captura</h2></header>
        <div class="content">
          <div class="video-wrap" id="videoWrap">
            <video id="video" playsinline muted></video>
            <div class="overlay"></div>
          </div>
          <div class="status" id="status">
            <span class="pill" id="motion">MSE: —</span>
            <span class="pill" id="sharp">Laplaciano: —</span>
            <span class="pill warn" id="hint">Aponte a lesão ao centro e mantenha firme</span>
          </div>
          <div class="row actions" style="margin-top:12px;justify-content:center">
        <button class="btn primary" id="openCam">Abrir câmera</button>
        <button class="btn" id="toggleFlash" disabled>Flash indisponível</button>
        <button class="btn big cta" id="capture" disabled>Capturar</button>
            <label for="file" class="btn">Importar imagem</label>
            <input type="file" id="file" accept="image/*" />
            <button class="btn" id="download" disabled>Baixar selecionado</button>
            <button class="btn" id="pickFolder">Escolher pasta destino</button>
            <button class="btn" id="saveToFolder" disabled>Salvar na pasta</button>
          </div>
          <div class="slider-wrap">
            <label for="circleSize">Diâmetro do círculo (% do menor lado do preview): <span id="circleVal">76</span>%</label>
            <input type="range" id="circleSize" min="50" max="95" value="76" />
          </div>
          <div class="foot">Dica: espere os indicadores ficarem verdes para capturar. O botão “Capturar” libera quando a cena está estável e nítida.</div>
        </div>
      </section>

      <!-- Resultado -->
      <section class="panel tab-panel" id="panelResult">
        <header><h2>Resultado</h2></header>
        <div class="content">
          <div class="row" style="justify-content:center;gap:16px">
            <canvas id="outCanvas" width="512" height="512" title="Original recortada"></canvas>
            <img id="segPreview" alt="Segmentação" style="max-width:512px;max-height:512px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:#0b1220" />
          </div>
      <div class="row" style="margin-top:12px;justify-content:center">
        <button class="btn" id="useOriginal" disabled>Não ficou bom — usar original</button>
        <button class="btn primary" id="useSegmented" disabled>Ficou bom — usar segmentada</button>
        <button class="btn cta" id="classifyBtn" disabled>Classificar</button>
      </div>
      <div class="foot" id="resultHint">Após a captura a segmentação será aplicada e mostrada ao lado.</div>
      <div class="foot" id="classResult"></div>
    </div>
  </section>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const openCamBtn = document.getElementById('openCam');
    const captureBtn = document.getElementById('capture');
    const downloadBtn = document.getElementById('download');
    const fileInput = document.getElementById('file');
    const outCanvas = document.getElementById('outCanvas');
    const segPreview = document.getElementById('segPreview');
    const overlay = document.querySelector('.overlay');
    const motionPill = document.getElementById('motion');
    const sharpPill = document.getElementById('sharp');
    const hintPill = document.getElementById('hint');
    const circleSizeSlider = document.getElementById('circleSize');
    const circleVal = document.getElementById('circleVal');
    const videoWrap = document.getElementById('videoWrap');
    const tabCapBtn = document.getElementById('tabCapBtn');
    const tabResBtn = document.getElementById('tabResBtn');
    const panelCapture = document.getElementById('panelCapture');
    const panelResult = document.getElementById('panelResult');
    const useOriginalBtn = document.getElementById('useOriginal');
    const useSegmentedBtn = document.getElementById('useSegmented');
    const resultHint = document.getElementById('resultHint');
    const classifyBtn = document.getElementById('classifyBtn');
    const classResult = document.getElementById('classResult');
    const flashBtn = document.getElementById('toggleFlash');

    let stream = null;
    let videoTrack = null;
    let rafId = null;
    let prevFrame = null;          // Uint8ClampedArray (grayscale)
    let analyzing = false;
    let originalBlob = null;       // Blob da imagem original recortada
    let segmentedBlob = null;      // Blob retornado pela API
    let chosenBlob = null;         // Blob escolhido (original ou segmentada)
    let flashOn = false;

    // thresholds (ajustáveis)
    let THRESH_MSE = 85;           // movimento (quanto menor melhor)
    let THRESH_LAPL = 80.0;        // nitidez (quanto maior melhor)
    let stableFramesNeeded = 8;    // frames estáveis para liberar captura
    let stableCounter = 0;

    // Canvas "offscreen" para análise
    const proc = document.createElement('canvas');
    const pctx = proc.getContext('2d', { willReadFrequently: true });

    function updateOverlay() {
      const pct = Number(circleSizeSlider.value);
      circleVal.textContent = pct;
      const stop = Math.max(0, Math.min(100, pct));
      overlay.style.background = `radial-gradient(circle at 50% 50%, transparent 0 ${stop - 1}%, rgba(0,0,0,.64) ${stop}% 100%)`;
    }
    circleSizeSlider.addEventListener('input', updateOverlay);
    updateOverlay();

    function updateFlashButton(){
      const supported = !!(videoTrack && videoTrack.getCapabilities && videoTrack.getCapabilities().torch);
      if (!supported){
        flashBtn.disabled = true;
        flashBtn.textContent = 'Flash indisponível';
        return;
      }
      flashBtn.disabled = false;
      flashBtn.textContent = flashOn ? 'Flash ligado' : 'Flash desligado';
    }

    async function openCamera() {
      if (stream) stream.getTracks().forEach(t => t.stop());
      stream = null; videoTrack = null; flashOn = false; updateFlashButton();
      async function tryGet(constraints){ return navigator.mediaDevices.getUserMedia(constraints); }
      const trials = [
        { video: { facingMode: { exact: 'environment' }, width:{ideal:1280}, height:{ideal:1706} }, audio:false },
        { video: { facingMode: 'environment', width:{ideal:1280}, height:{ideal:1706} }, audio:false },
        { video: { facingMode: 'user', width:{ideal:1280}, height:{ideal:1706} }, audio:false },
        { video: true, audio: false }
      ];
      let lastErr = null;
      for (const c of trials){
        try{
          const s = await tryGet(c);
          stream = s; video.srcObject = s; await video.play();
          videoTrack = stream.getVideoTracks()[0] || null;
          startAnalyzeLoop();
          updateFlashButton();
          return;
        }catch(e){ lastErr = e; }
      }
      let hint = 'Não foi possível acessar a câmera.';
      if (lastErr && lastErr.name === 'NotAllowedError') hint = 'Permissão negada. Habilite a câmera para este site.';
      else if (lastErr && lastErr.name === 'NotFoundError') hint = 'Nenhuma câmera encontrada ou está bloqueada.';
      else if (lastErr && lastErr.name === 'NotReadableError') hint = 'A câmera está em uso por outro app.';
      else if (lastErr && lastErr.name === 'OverconstrainedError') hint = 'Resolução/facingMode não suportado pela câmera.';
      else if (lastErr && lastErr.name === 'SecurityError') hint = 'Abra via HTTPS ou localhost (não use file://).';
      alert(hint);
      updateFlashButton();
    }

    function startAnalyzeLoop(){
      analyzing = true;
      function fitProc(){
        const w = video.videoWidth, h = video.videoHeight;
        if (w && h){ proc.width = Math.floor(w/2); proc.height = Math.floor(h/2); }
      }
      fitProc();
      const loop = () => {
        if (!analyzing) return;
        try{
          pctx.drawImage(video, 0, 0, proc.width, proc.height);
          const frame = pctx.getImageData(0, 0, proc.width, proc.height).data;
          const gray = new Uint8ClampedArray(proc.width * proc.height);
          for (let i=0,j=0;i<frame.length;i+=4,j++) gray[j] = (0.2126*frame[i] + 0.7152*frame[i+1] + 0.0722*frame[i+2])|0;
          let mse = 0;
          if (prevFrame && prevFrame.length === gray.length){
            let sum=0; for (let k=0;k<gray.length;k++){ const d=gray[k]-prevFrame[k]; sum+=d*d; }
            mse = sum/gray.length;
          }
          prevFrame = gray;
          let sumL=0, sumL2=0; const w=proc.width, h=proc.height;
          for (let y=1;y<h-1;y++) for (let x=1;x<w-1;x++){
            const i=y*w+x; const L=(gray[i-w] + gray[i-1] - 4*gray[i] + gray[i+1] + gray[i+w]); sumL+=L; sumL2+=L*L;
          }
          const n=(w-2)*(h-2); const meanL=sumL/n; const varL=(sumL2/n)-(meanL*meanL); const lapSharpness=Math.max(0,varL);
          motionPill.textContent = `MSE: ${mse.toFixed(1)}`;
          sharpPill.textContent  = `Laplaciano: ${lapSharpness.toFixed(0)}`;
          const motionOK = mse < THRESH_MSE; const sharpOK = lapSharpness > THRESH_LAPL;
          setPillClass(motionPill, motionOK ? 'good' : (mse < THRESH_MSE*1.3 ? 'warn':'bad'));
          setPillClass(sharpPill, sharpOK ? 'good' : (lapSharpness > THRESH_LAPL*0.3 ? 'warn':'bad'));
          if (motionOK && sharpOK) stableCounter = Math.min(stableFramesNeeded, stableCounter+1); else stableCounter = 0;
          if (stableCounter >= stableFramesNeeded){ captureBtn.disabled=false; hintPill.textContent='Estável e nítido — pode capturar.'; setPillClass(hintPill,'good'); }
          else { captureBtn.disabled=true; hintPill.textContent='Mantenha firme... aguardando estabilidade'; setPillClass(hintPill,'warn'); }
        }catch(e){ console.warn(e); }
        rafId = requestAnimationFrame(loop);
      };
      cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(loop);
    }

    function setPillClass(el, kind){ el.classList.remove('good','warn','bad'); if (kind) el.classList.add(kind); }
    function stopAnalyze(){ analyzing=false; cancelAnimationFrame(rafId); }

    function drawCircularCropTo(canvas, source, centerX, centerY, radiusPx){
      const ctx = canvas.getContext('2d');
      const outSize = Math.min(canvas.width, canvas.height);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.beginPath(); ctx.arc(outSize/2, outSize/2, outSize/2 - 2, 0, Math.PI*2); ctx.closePath(); ctx.clip();
      const s = radiusPx*2;
      ctx.drawImage(source, centerX-radiusPx, centerY-radiusPx, s, s, 0, 0, outSize, outSize);
      ctx.restore();
    }

    function getCircleOnVideo(){
      const vw = video.videoWidth, vh = video.videoHeight; if (!vw||!vh) return null;
      const pct = Number(circleSizeSlider.value)/100; const r = Math.min(vw, vh) * pct / 2; return { cx: vw/2, cy: vh/2, r };
    }

    async function toBlob(canvas, type='image/png', quality){ return await new Promise(res => canvas.toBlob(res, type, quality)); }
    function setActiveTab(which){ const cap=which==='cap'; tabCapBtn.classList.toggle('active',cap); tabResBtn.classList.toggle('active',!cap); panelCapture.classList.toggle('hidden',!cap); panelResult.classList.toggle('hidden',cap); }
    tabCapBtn?.addEventListener('click', ()=>setActiveTab('cap'));
    tabResBtn?.addEventListener('click', ()=>setActiveTab('res'));
    setActiveTab('cap');

    // Base da API: quando a página é servida em 5500 (dev), chama a API em 5000.
    const currentHost = location.hostname || '127.0.0.1';
    let API_BASE = '';
    if (location.protocol === 'file:') {
      API_BASE = `http://${currentHost}:5000`;
    } else if (location.port && location.port !== '5000') {
      API_BASE = `${location.protocol}//${currentHost}:5000`;
    }

    async function runSegmentation(blob){
      try{
        resultHint.textContent = 'Processando segmentação...';
        const fd = new FormData(); fd.append('image', blob, 'captura.png');
        const resp = await fetch(`${API_BASE}/segment`, { method:'POST', body: fd });
        if (!resp.ok) throw new Error('Falha na API: '+resp.status);
        const out = await resp.blob(); resultHint.textContent = 'Compare e escolha a melhor opção.'; return out;
      }catch(err){ console.warn('Erro ao segmentar:', err); resultHint.textContent = 'Não foi possível segmentar (API offline?). Você pode usar a original.'; return null; }
    }

    captureBtn.addEventListener('click', async () => {
      const tmp = document.createElement('canvas');
      const vw = video.videoWidth, vh = video.videoHeight; tmp.width = vw; tmp.height = vh; tmp.getContext('2d').drawImage(video, 0, 0, vw, vh);
      const circ = getCircleOnVideo(); if (!circ) return;
      drawCircularCropTo(outCanvas, tmp, circ.cx, circ.cy, circ.r);
      originalBlob = await toBlob(outCanvas, 'image/png'); chosenBlob = originalBlob; useOriginalBtn.disabled = false; setActiveTab('res');
      segmentedBlob = await runSegmentation(originalBlob);
      if (segmentedBlob){ segPreview.src = URL.createObjectURL(segmentedBlob); useSegmentedBtn.disabled = false; chosenBlob = segmentedBlob; }
      downloadBtn.disabled = false;
      classifyBtn.disabled = false;
      classResult.textContent = '';
    });

    openCamBtn.addEventListener('click', async ()=>{ await openCamera(); });

    downloadBtn.addEventListener('click', async () => {
      let blob = chosenBlob || (await toBlob(outCanvas,'image/png'));
      const link = document.createElement('a');
      link.download = chosenBlob === segmentedBlob ? 'lesao_segmentada.png' : 'lesao_original.png';
      link.href = URL.createObjectURL(blob); link.click();
    });

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      const img = new Image();
      img.onload = async () => {
        const minSide = Math.min(img.width, img.height);
        const r = minSide * (Number(circleSizeSlider.value)/100) / 2;
        drawCircularCropTo(outCanvas, img, img.width/2, img.height/2, r);
        originalBlob = await toBlob(outCanvas,'image/png'); chosenBlob = originalBlob; useOriginalBtn.disabled = true; setActiveTab('res');
        segmentedBlob = await runSegmentation(originalBlob);
        if (segmentedBlob){ segPreview.src = URL.createObjectURL(segmentedBlob); useSegmentedBtn.disabled = false; chosenBlob = segmentedBlob; }
        downloadBtn.disabled = false; useOriginalBtn.disabled = false; classifyBtn.disabled = false; classResult.textContent = '';
      };
      img.src = URL.createObjectURL(file);
    });

    // Escolhas do usuário
    async function saveToServer(blob, kind){
      try{
        const fd = new FormData();
        fd.append('image', blob, kind === 'segmented' ? 'lesao_segmentada.png' : 'lesao_original.png');
        fd.append('kind', kind);
        const r = await fetch(`${API_BASE}/save`, { method: 'POST', body: fd });
        const js = await r.json();
        if (!r.ok) throw new Error(js.error || 'Falha ao salvar');
        alert('Imagem salva em: ' + js.path);
      }catch(e){ console.warn(e); alert('Não foi possível salvar no servidor.'); }
    }

    useOriginalBtn.addEventListener('click', async ()=>{
      if(originalBlob){ chosenBlob = originalBlob; }
      // Se desejar salvar automaticamente também a original, descomente:
      // if (originalBlob) await saveToServer(originalBlob, 'original');
    });

    useSegmentedBtn.addEventListener('click', async ()=>{
      if(segmentedBlob){ chosenBlob = segmentedBlob; await saveToServer(segmentedBlob, 'segmented'); }
    });

    classifyBtn.addEventListener('click', async ()=>{
      if (!chosenBlob){ alert('Capture ou importe uma imagem primeiro.'); return; }
      classResult.textContent = 'Classificando...';
      try{
        const fd = new FormData();
        const name = chosenBlob === segmentedBlob ? 'lesao_segmentada.png' : 'lesao_original.png';
        fd.append('image', chosenBlob, name);
        const resp = await fetch(`${API_BASE}/classify`, { method:'POST', body: fd });
        const js = await resp.json();
        if (!resp.ok) throw new Error(js.error || 'Falha ao classificar');
        const probs = js.probabilities || {};
        const probText = Object.entries(probs).map(([k,v])=>`${k}: ${(Number(v)*100).toFixed(1)}%`).join(' | ');
        classResult.textContent = `Classe: ${js.prediction} — ${probText}`;
      }catch(e){
        console.warn(e);
        classResult.textContent = 'Erro ao classificar. Verifique se a API está rodando.';
      }
    });

    // Salvamento em pasta (File System Access API)
    const pickFolderBtn = document.getElementById('pickFolder');
    const saveToFolderBtn = document.getElementById('saveToFolder');
    let chosenDir = null;
    pickFolderBtn?.addEventListener('click', async ()=>{
      if (!window.showDirectoryPicker){ alert('Seu navegador não suporta salvar direto em pasta. Use “Baixar selecionado”.'); return; }
      try{ chosenDir = await window.showDirectoryPicker(); saveToFolderBtn.disabled = false; }catch(e){ console.warn(e); }
    });
    saveToFolderBtn?.addEventListener('click', async ()=>{
      try{
        const blob = chosenBlob || await toBlob(outCanvas,'image/png');
        const name = chosenBlob === segmentedBlob ? 'lesao_segmentada.png' : 'lesao_original.png';
        const fh = await chosenDir.getFileHandle(name, { create:true });
        const ws = await fh.createWritable(); await ws.write(blob); await ws.close();
        alert('Imagem salva na pasta selecionada.');
      }catch(e){ console.warn(e); alert('Não foi possível salvar.'); }
    });

    // limpeza ao sair
    window.addEventListener('beforeunload', () => { stopAnalyze(); if (stream) stream.getTracks().forEach(t => t.stop()); });
    document.addEventListener('keydown', (ev) => { if (ev.key === 'c' && !captureBtn.disabled) captureBtn.click(); });
    flashBtn.addEventListener('click', async () => {
      if (!videoTrack){ return; }
      const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
      if (!caps.torch){
        alert('Este dispositivo não suporta controle de flash via navegador.');
        return;
      }
      try{
        const newState = !flashOn;
        await videoTrack.applyConstraints({ advanced: [{ torch: newState }] });
        flashOn = newState;
      }catch(err){
        console.warn('Falha ao ajustar flash', err);
        alert('Não foi possível alternar o flash. Verifique permissões do navegador.');
      }
      updateFlashButton();
    });
  </script>
</body>
</html>

